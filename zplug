#!/bin/zsh
#              _
#    _____ __ | |_   _  __ _
#   |_  / '_ \| | | | |/ _` |
#    / /| |_) | | |_| | (_| |
#   /___| .__/|_|\__,_|\__, |
#       |_|            |___/
#
#  zplug: zsh plugin manager
# ===========================
#
# zplug is next-generation zsh plugin manager.
#
# Pros.
#
# - Can manage everything
#   - Zsh plugins/UNIX commands on GitHub and Bitbucket
#   - Gist file (gist.github.com)
#   - Externally managed plugins e.g., oh-my-zsh plugins
#   - Birary artifacts on GitHub Releases
#   - etc.
# - Super-fast parallel installation/update
# - Branch/tag/commit support
# - Post-update hooks
# - Understands dependencies between plugins
# - Unlike antigen, no ZSH plugin file (*.plugin.zsh) required
# - Interactive interface (fzf, peco, zaw, and so on)
#
# Download zplug and put it in ~/.zplug
#
#   curl -fLo ~/.zplug/zplug --create-dirs https://git.io/zplug
#
# Edit your .zshrc
#
: <<'EXAMPLE'
source ~/.zplug/zplug

# Make sure you use double quotes
zplug "zsh-users/zsh-syntax-highlighting"
zplug "zsh-users/zsh-history-substring-search"

# Can manage a plugin as a command
# And accept glob patterns (e.g., brace, wildcard, ...)
zplug "Jxck/dotfiles", as:command, of:"bin/{histuniq,color}"

# Can manage everything e.g., other person's zshrc
zplug "tcnksm/docker-alias", of:zshrc

# Prohibit updates to a plugin by using the "frozen:" tag
zplug "k4rthik/git-cal", as:command, frozen:1

# Grab binaries from GitHub Releases
# and rename to use "file:" tag
zplug "junegunn/fzf-bin", \
    as:command, \
    from:gh-r, \
    file:fzf

# Support oh-my-zsh plugins and the like
zplug "plugins/git",   from:oh-my-zsh
zplug "themes/duellj", from:oh-my-zsh
zplug "lib/clipboard", from:oh-my-zsh

# Run a command after a plugin is installed/updated
zplug "tj/n", do:"make install"

# Support checking out a specific branch/tag/commit of a plugin
zplug "b4b4r07/enhancd", at:v1
zplug "mollifier/anyframe", commit:4c23cb60

# Install if "if:" tag returns true
zplug "hchbaw/opp.zsh", if:"(( ${ZSH_VERSION%%.*} < 5 ))"

# Can manage gist file just like other plugins
zplug "b4b4r07/79ee61f7c140c63d2786", \
    from:gist, \
    as:command, \
    of:get_last_pane_path.sh

# Support bitbucket
zplug "b4b4r07/hello_bitbucket", \
    as:command
    from:bitbucket, \
    do:"chmod 755 *.sh", \
    of:"*.sh"

# Group dependencies, emoji-cli depends on jq in this example
zplug "stedolan/jq", \
    as:command, \
    file:jq, \
    from:gh-r \
    | zplug "b4b4r07/emoji-cli"

# Install plugins if there are plugins that have not been installed
if ! zplug check --verbose; then
    printf "Install? [y/N]: "
    if read -q; then
        echo; zplug install
    fi
fi

# Then, source plugins and add commands to $PATH
zplug load --verbose

EXAMPLE

#
# Then reload .zshrc and `zplug install; zplug load` to install plugins.
# Visit https://github.com/b4b4r07/zplug for more information.
#
# In order for this plugin to work properly,
# you must be launching zsh 4.3.9 or more.
#
# The MIT License (MIT)
# Copyright (c) 2015 Masaki Ishiyama <b4b4r07@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

typeset -gx ZPLUG_HOME=${ZPLUG_HOME:-~/.zplug}
typeset -gx ZPLUG_THREADS=${ZPLUG_THREADS:-16}
typeset -gx ZPLUG_SHALLOW=${ZPLUG_SHALLOW:-true}
typeset -gx ZPLUG_PROTOCOL=${ZPLUG_PROTOCOL:-HTTPS}
typeset -gx ZPLUG_FILTER=${ZPLUG_FILTER:-"fzf-tmux:fzf:peco:percol:zaw"}

typeset -gx ZPLUG_EXTERNAL=${ZPLUG_EXTERNAL:-$ZPLUG_HOME/init.zsh}
typeset -gx ZPLUG_USE_CACHE=true

# To make zplug readable
functions zplug &>/dev/null || {
typeset -gr ZPLUG_NAME="zplug"
typeset -gr ZPLUG_VERSION="0.1.9"
typeset -gr ZPLUG_RAWURL="https://git.io/zplug"
typeset -gr ZPLUG_URL="https://github.com/b4b4r07/zplug"
typeset -gr ZPLUG_HELP="usage: zplug [COMMANDS] [OPTIONS]
  $ZPLUG_NAME is next-generation zsh plugin manager

COMMANDS:
  help      Show this help message and usage
  version   Show version information
  install   Install described items in parallel
  update    Update items in parallel
  load      Source plugins to current shell and add $ZPLUG_HOME/bin to \$PATH
  list      Show all of the zplugs in the current shell
  check     Check whether an update or installation is available
  status    Check if remote branch is up-to-date
  clean     Remove repositories which is no longer managed
  clear     Remove the cache file

For more information, see also $ZPLUG_URL."
typeset -gr _zplug_omz_repo="robbyrussell/oh-my-zsh"
typeset -gr _zplug_tag_pattern="as|of|from|if|dir|file|at|do|frozen|on|commit|nice|ignore"
typeset -gr ZPLUG_CACHE_FILE=$ZPLUG_HOME/.cache
}

typeset -gx -A zplugs

#
# zplug utilities
#

__die() {
    command printf -- "$@" >&2
}

__put() {
    command printf -- "$@"
}

__ink() {
    local color tty=1 is_bold=false
    local -a text

    while (( $# > 0 )); do
        case "$1" in
            --color)
                if [[ ! $2 =~ ^(black|blue|cyan|default|green|grey|magenta|red|white|yellow)$ ]]; then
                    __die "$2: must be a color"
                    return 1
                fi
                color="$2"; shift
                ;;
            --bold)
                is_bold=true
                ;;
            --tty)
                if [[ $2 != <-> ]]; then
                    __die "$2: must be an interger"
                    return 1
                fi
                tty="$2"; shift
                ;;
            *)
                text+=("$1")
                ;;
        esac
        shift
    done

    if $is_bold; then
        color="$fg_bold[$color]"
    else
        color="$fg_no_bold[$color]"
    fi

    case $tty in
        1)
            __put "${color}${text}${reset_color}"
            ;;
        2)
            __die "${color}${text}${reset_color}"
            ;;
    esac
}

__log() {
    local state text
    state="$1"
    text="$2"

    local bold tty=1

    case "$state" in
        TITLE)
            color="yellow"
            ;;
        INFO)
            color="blue"
            ;;
        FAIL | WARN)
            color="red"
            tty=2
            ;;
        ERROR)
            color="red"
            bold="--bold"
            tty=2
            ;;
        PASS)
            color="green"
            ;;
        SUCCESS)
            bold="--bold"
            color="green"
            ;;
        *)
            text="$1"
            ;;
    esac

    __ink --color white "["
    __ink --color magenta --bold "$(date +%H:%M:%S)"
    __ink --color white "]"
    __ink --color "$color" --tty "$tty" $bold " $text"
}

__get_filter() {
    local item x

    for item in "${(s.:.)1}"
    do
        x="${item%% *}"
        # Check if x is available
        if (( $+commands[$x] )); then
            echo "$x"
            return 0
        else
            continue
        fi
    done

    return 1
}

__version_requirement() {
    local idx
    local -a min val

    [[ $1 == $2 ]] && return 0

    val=("${(s:.:)1}")
    min=("${(s:.:)2}")

    for (( idx=1; idx <= $#val; idx++ ))
    do
        if (( val[$idx] > ${min[$idx]:-0} )); then
            return 0
        elif (( val[$idx] < ${min[$idx]:-0} )); then
            return 1
        fi
    done

    return 1
}

__git_version() {
    __version_requirement ${(M)${(z)"$(git --version)"}:#[0-9]*[0-9]} "$@"
    return $status
}

__zsh_version() {
    __version_requirement "$ZSH_VERSION" "$@"
    return $status
}

__job_control() {
    case "$1" in
        on)
            # default in interactive shell
            set -o monitor
            ;;
        off)
            # no job control in this shell.
            set +o monitor
            ;;
        "")
            # on/off
            echo ${${(M)${(@f)"$(set -o)"}:#monitor*}[2]}
            ;;
        *)
            return 1
            ;;
    esac
}

__bg_rotation_bar() {
    local current_count simbol
    for ((current_count=0; ; current_count++))
    do
        let simbol=current_count%4
        case "$simbol" in
            0) echo -ne " |\r";;
            1) echo -ne " /\r";;
            2) echo -ne " -\r";;
            3) echo -ne " \\\\\r";;
        esac
        sleep 0.05
    done
}

__zplug::releases()
{
    # Work with git.io/releases
    # For more information, see also https://github.com/b4b4r07/releases

    if (( $+commands[curl] )); then
        L="$1" V="${3:-latest}" bash -c "$(curl -fsSL git.io/releases)" -s "${2:-os}"
        return $status

    elif (( $+commands[wget] )); then
        L="$1" V="${3:-latest}" bash -c "$(wget -qO - git.io/releases)" -s "${2:-os}"
        return $status

    fi >/dev/null 2>&1

    __die "$ZPLUG_NAME: requires curl or wget for from:gh-r\n"
    return 1
}

__zplug::list()
{
    if (( $#zplugs < 1 )); then
        __die "$ZPLUG_NAME: there is no available plugins\n"
        return 1
    fi

    local v arg is_select=false
    local -a args awk_args
    local -A out

    for v in "${(@nO)zplugs}"
    do
        out+=("${(@kv)zplugs[(eR)$v]}")
    done

    case "$1" in
        --select)
            is_select=true
            shift
            ;;
        -*|--*)
            __die "$1: Unknown option\n"
            return 1
            ;;
    esac

    filter="$(__get_filter "$ZPLUG_FILTER")"
    if $is_select; then
        args=(${(@f)"$(echo "${(Fk)zplugs}" | eval "$filter")"})
        (( $#args == 0 )) && return 0
    else
        args=("$@")
    fi

    if (( $#args > 0 )); then
        out=()
        for arg in "${args[@]}"
        do
            if (( $+zplugs[$arg] )); then
                # This is compelte match
                out+=("$arg" "${zplugs[$arg]}")
            else
                # Fuzzy match with awk
                awk_args=(${(@f)"$(awk -v arg=$arg '$1 ~ arg' <<<${(Fk)zplugs})"})
                for arg in ${awk_args[@]}
                do
                    if (( $+zplugs[$arg] )); then
                        out+=("$arg" "${zplugs[$arg]}")
                    fi
                done
            fi
        done
    fi

    if (( $#out < 1 )); then
        __die "$arg: not found in \$zplugs\n"
        return 1
    fi
    __put '%s  =>  %s\n' "${(@kv)out:gs:@::}" \
        | sed -e 's/-EMP-/""/g' \
        | perl -pe 's/^(.*)( *=>.*)$/\033[32m$1\033[m$2/g' \
        | perl -pe 's/('"$_zplug_tag_pattern"')(:)/\033[34m$1\033[m$2/g'
}

__zplug::self_update()
{
    trap 'kill -9 $bg_pid &>/dev/null; __job_control on; trap - EXIT INT' EXIT INT
    local zplug
    zplug="b4b4r07/zplug"

    __put "\033[;1m * zplug self management\033[m\n"

    zplug check "$zplug" || zplug "$zplug"
    if [[ -d $ZPLUG_HOME/repos/b4b4r07/zplug ]]; then
        __zplug::update "$zplug"
    else
        ZPLUG_SHALLOW=false __zplug::install "$zplug"
    fi

    ln -snf "$ZPLUG_HOME/repos/$zplug/zplug" "$ZPLUG_HOME/zplug"
    if [[ $status -eq 0 && -d $ZPLUG_HOME/repos/b4b4r07/zplug && -f $ZPLUG_HOME/zplug ]]; then
        __put "\033[32mEverything is ready. \033[;1m($ZPLUG_HOME/zplug)\033[m\n"
    else
        __die "\033[31mError occured (see $ZPLUG_URL)\033[m\n"
        return 1
    fi
}

__zplug::v2()
{
    local -i ret=0

    if [[ -d $ZPLUG_HOME ]]; then
        command mv -f \
            "$ZPLUG_HOME" \
            "${ZPLUG_HOME}_v1"
    fi

    if (( $+commands[curl] )); then
        zsh -c "$(curl -fsSL "$ZPLUG_RAWURL" 2>/dev/null)" ${1:+"-s $@"}
        ret=$status

    elif (( $+commands[wget] )); then
        zsh -c "$(wget -qO - "$ZPLUG_RAWURL" 2>/dev/null)" ${1:+"-s $@"}
        ret=$status

    fi

    return $ret
}

__zplug::update()
{
    local line cnt=0 filter is_select=false
    local -a args

    case "$1" in
        --self)
            __zplug::self_update
            return $status
            ;;
        --self-v2)
            __zplug::v2
            return $status
            ;;
        --select)
            is_select=true
            shift
            ;;
        -*|--*)
            __die "$1: Unknown option\n"
            return 1
            ;;
    esac

    __job_control off

    filter="$(__get_filter "$ZPLUG_FILTER")"
    if $is_select; then
        args=(${(@f)"$(echo "${(Fk)zplugs}" | eval "$filter")"})
    else
        args=(${(u)${@:gs:@::}})
    fi

    local max=0
    for line in "${args[@]}"; do
        (( $#line > max )) && max=$#line
    done

    for line in "${args[@]}"; do
        # Run installation in subprocess
        {
            trap 'kill -9 ${${(v)jobstates##*:*:}%"="*} $bg_pid &>/dev/null; __job_control on; trap - INT' INT

            # All variables are treated as local variable
            # because of background job (subprocess)
            local k bg_pid ret=1
            local -A zspec
            zspec=( ${(@f)"$(__zplug::parser "$line")"} )
            for k in ${(k)zspec}
            do
                if [[ $zspec[$k] == "-EMP-" ]]; then
                    zspec[$k]=""
                fi
            done
            [[ $zspec[from] == "local" ]] && continue

            typeset -F SECONDS=0

            # Not update
            if [[ $zspec[frozen] -eq 1 ]]; then
                if [[ ${#@} -eq 1 && ${@[1]} == $zspec[name] ]]; then
                    __put "\033[32m$zspec[name]\033[m: \033[34mfrozen repo\033[m. Update? [y/N]: "
                    if ! read -q; then
                        continue
                    fi
                    echo
                else
                    # Frozen!!
                    __put " \033[34m* Frozen\033[m    $line\n"
                    continue
                fi
            fi

            __put "Updating...  $line\n"

            __bg_rotation_bar & bg_pid=$!

            () {
                # Change directory to fullpath of zspec dir
                # or parent directory of zspec dir
                # If it fails, return this unnamed function with error code 2
                builtin cd $zspec[dir] || builtin cd ${zspec[dir]%/*} || return 2

                # If zspec from is gh-r (GitHub Releases),
                # send a http request to git.io/releases with os argument
                # or, git pull (case of normal plugin)
                if [[ $zspec[from] == "gh-r" ]]; then
                    __zplug::releases $zspec[name] $zspec[of] ${zspec[at]:#master}
                else
                    local fetch_opt
                    if [[ -e $zspec[dir]/.git/shallow ]]; then
                        fetch_opt='--unshallow'
                    fi
                    git fetch $fetch_opt
                    git checkout -q $zspec[at]

                    local rev_local rev_remote rev_base
                    rev_local=$(git rev-parse HEAD)
                    rev_remote=$(git rev-parse "@{u}")
                    rev_base=$(git merge-base HEAD "@{u}")

                    if [[ $rev_local == $rev_remote ]]; then
                        # up-to-date
                        return 128
                    elif [[ $rev_local = $rev_base ]]; then
                        # need to pull
                        git merge --ff-only origin/$zspec[at] && git submodule update --init --recursive
                        return $status
                    elif [ $rev_remote = $rev_base ]; then
                        # need to push
                        return 1
                    else
                        # Diverged
                        return 1
                    fi
                fi
            } >/dev/null 2>&1
            # Return code of above unnamed function
            # Incidentally,
            # nothing is output even if it success or fails
            ret=$status

            if [[ -n $zspec[do] ]]; then
                if [[ $ret -eq 0 ]]; then
                    (
                    builtin cd -q "$zspec[dir]"
                    eval "$zspec[do]"
                    )
                fi
            fi

            kill -9 $bg_pid &>/dev/null

            case $ret in
                0)
                    __put "\033[32mUpdated!\033[m     %-${max}s\t(%.2fs)\n" "$line" $SECONDS
                    ;;
                1)
                    __put "\033[31mNot Updated\033[m  %-${max}s\t(%.2fs)\n" "$line" $SECONDS
                    ;;
                2)
                    # Simple manual synchronous processing
                    sleep 1
                    # Output in magenta
                    # and SECONDS-1 (sleep 1)
                    __put "\033[35mNot Found\033[m    %-${max}s\t(%.2fs)\n" "$line" $((SECONDS-1))
                    ;;
                128)
                    __put "%s   %-${max}s\t(%.2fs)\n" $(__ink --color white "Up-to-date") "$line" $SECONDS
                    ;;
            esac
        } &

        # Prevent having too many subprocesses
        (( (cnt += 1) % ZPLUG_THREADS == 0 )) && wait
    done

    # Wait until all jobs known to the invoking shell have terminated
    wait

    __job_control on
}

__zplug::install()
{
    local cnt line fail job filter max
    local start end
    local is_verbose=false is_select=false
    local -a args check
    local oh_my_line oh_my_count=0
    local -A zspec
    cnt=0
    max=0
    fail=0

    [[ -d $ZPLUG_HOME/repos ]] || mkdir -p "$ZPLUG_HOME/repos"

    case "$1" in
        --verbose)
            is_verbose=true
            shift
            ;;
        --select)
            is_select=true
            shift
            ;;
        "")
            return 1
            ;;
        -*|--*)
            __die "$1: Unknown option\n"
            return 1
            ;;
    esac

    __job_control off

    filter="$(__get_filter "$ZPLUG_FILTER")"
    if $is_select; then
        args=(${(@f)"$(echo "${(F)@}" | eval "$filter")"})
    else
        args=(${(u)${@:gs:@::}})
    fi

    typeset -F SECONDS=0
    start=$SECONDS

    for line in "${args[@]}"; do
        (( $#line > max )) && max=$#line
    done

    for line in "${args[@]}"; do
        # Parse line
        zspec=( ${(@f)"$(__zplug::parser "$line")"} )
        for k in ${(k)zspec}
        do
            if [[ $zspec[$k] == "-EMP-" ]]; then
                zspec[$k]=""
            fi
        done

        # For checking
        check+=($zspec[dir])

        # Skip installed items
        [[ $zspec[from] == "local" ]] && continue
        [[ -e $ZPLUG_HOME/repos/$line ]] || [[ $zspec[from] == "oh-my-zsh" && -d $ZPLUG_HOME/repos/$_zplug_omz_repo/$line ]] &&
            {
                if $is_verbose; then
                    __put "\033[31m-\033[m \033[32m${line}\033[m: already installed\n"
                fi
                continue
            }

        # if tag not satisfied
        if [[ -n $zspec[if] ]]; then
            if ! eval "$zspec[if]" >/dev/null 2>&1; then
                __put "$line skipped due to if condition\n"
                continue
            fi
        fi

        # Case of oh-my-zsh
        oh_my_line=""
        [[ $zspec[from] == "oh-my-zsh" ]] &&
            {
                (( oh_my_count++ > 0 )) && continue
                [[ -d $ZPLUG_HOME/repos/$_zplug_omz_repo ]] && continue
                oh_my_line="$_zplug_omz_repo"
            }

        # Run installation in subprocess
        {
            trap 'kill -9 ${${(v)jobstates##*:*:}%"="*} $bg_pid &>/dev/null; __job_control on; trap - INT' INT

            # All variables are treated as local variable
            # because of background job (subprocess)
            local bg_pid ret
            typeset -F SECONDS=0

            __put "Installing...  ${oh_my_line:-$line}\n"

            __bg_rotation_bar & bg_pid=$!
            builtin cd $ZPLUG_HOME/repos >/dev/null 2>&1

            # If zspec from is gh-r (GitHub Releases),
            # send a http request to git.io/releases with os argument
            # or, git clone (case of normal plugin)
            __zplug::clone \
                --of "${zspec[of]:-""}" \
                --commit "${zspec[commit]:-""}" \
                --from "${zspec[from]:-""}" \
                --at "${zspec[at]:-""}" \
                --do "${zspec[do]:-""}" \
                "$line"
            ret=$status

            kill -9 $bg_pid &>/dev/null

            if [[ $ret -eq 0 ]]; then
                __put "\033[32mInstalled!\033[m     %-${max}s\t(%.2fs)\n" "${oh_my_line:-$line}" $SECONDS
            else
                __put "\033[31mNot Installed\033[m  %-${max}s\t(%.2fs)\n" "${oh_my_line:-$line}" $SECONDS
                # Return error exit code
                false
            fi
        } &

        # Prevent having too many subprocesses
        (( (cnt += 1) % ZPLUG_THREADS == 0 )) && wait
    done

    # Pauses until execution of a background process has ended
    for job in ${${(v)jobstates##*:*:}%"="*}
    do
        wait $job
    done >/dev/null 2>&1

    # Wait until all jobs known to the invoking shell have terminated
    wait

    __job_control on

    # Skip footer prints
    if [[ $cnt -eq 0 ]]; then
        return 0
    fi

    for line in "${check[@]}"; do
        [[ -e $line ]] || let fail++
    done
    if [[ $fail -eq 0 ]]; then
        __put "\033[;1m ==> Installed all plugins to $ZPLUG_HOME/repos, successfully!\033[m\n"
    else
        __die "\033[31;1m ==> Installed to $ZPLUG_HOME/repos but failed.\033[m\n"
    fi

    end=$SECONDS

    __put "$ZPLUG_NAME: total wall-time %f sec.\n" $(($end - $start))

    return $fail
}

__zplug::parser()
{
    local arg parsed_zplugs
    arg="$1"
    arg="${arg}, ${zplugs[$arg]%, }"

    parsed_zplugs=(${(s/, /)arg:gs/,  */, })

    local name as of from if dir file at do frozen on commit nice ignore
    name="${parsed_zplugs[1]}"
    as=${${${(M)parsed_zplugs:#as:*}#*:}:-plugin}
    of=${${${(M)parsed_zplugs:#of:*}#*:}:--EMP-}
    from=${${${(M)parsed_zplugs:#from:*}#*:}:-github}
    if=${${${(M)parsed_zplugs:#if:*}#*:}:--EMP-}
    dir=${${${(M)parsed_zplugs:#dir:*}#*:}:--EMP-}
    file=${${${(M)parsed_zplugs:#file:*}#*:}:--EMP-}
    at=${${${(M)parsed_zplugs:#at:*}#*:}:-master}
    do=${${${(M)parsed_zplugs:#do:*}#*:}:--EMP-}
    frozen=${${${(M)parsed_zplugs:#frozen:*}#*:}:-0}
    on=${${${(M)parsed_zplugs:#on:*}#*:}:--EMP-}
    commit=${${${(M)parsed_zplugs:#commit:*}#*:}:--EMP-}
    nice=${${${(M)parsed_zplugs:#nice:*}#*:}:-0}
    ignore=${${${(M)parsed_zplugs:#ignore:*}#*:}:--EMP-}

    if [[ $name == $_zplug_omz_repo ]] && [[ $nice -eq 0 ]]; then
        nice=-10
    fi

    local -A zplugs_tags
    zplugs_tags=(
      name    "$name"
      as      "$as"
      of      "$of"
      from    "$from"
      if      "$if"
      dir     "$dir"
      file    "$file"
      at      "$at"
      do      "$do"
      frozen  "$frozen"
      on      "$on"
      commit  "$commit"
      nice    "$nice"
      ignore  "$ignore"
    )

    # Output zplugs_tags
    # Separated by newline
    # because it is used by parameter expansion flags (@f)
    local key
    for key in ${(k)zplugs_tags}
    do
        echo "$key"
        echo "$zplugs_tags[$key]"
    done
}

__zplug::load()
{
    local is_verbose=false
    local loaded_omz=false

    case "$1" in
        --verbose)
            is_verbose=true
            shift
            ;;
        -*|--*)
            __die "$1: Unknown option\n"
            return 1
            ;;
    esac

    if (( $#funcstack[@] <= 6 )) && $ZPLUG_USE_CACHE && [[ -f $ZPLUG_CACHE_FILE ]]; then
        source $ZPLUG_CACHE_FILE
        return $status
    fi

    local key k
    local -A zspec

    local f ext
    local dirname basename
    local src dst
    local -a src_a
    local ignore
    local -A load_commands
    local -a load_plugins load_fpaths
    local -a load_ignores
    local -a temporary_array
    local -a themes_ext plugins_ext glob_patterns
    local -a args unsorted_nice nice_plugins
    args=(${(k)zplugs})

    # Order by nice value
    for key in ${args[@]}
    do
        zspec=( ${(@f)"$(__zplug::parser "$key")"} )
        unsorted_nice+=("$zspec[nice]:$zspec[name]")
    done

    for key in ${${(OnM)unsorted_nice:#-*}#*:} ${${(on)unsorted_nice:#-*}#*:}
    do
        zspec=( ${(@f)"$(__zplug::parser "$key")"} )
        for k in ${(k)zspec}
        do
            if [[ $zspec[$k] == "-EMP-" ]]; then
                zspec[$k]=""
            fi
        done

        {   # Skip cases
            if [[ $zspec[from] == "oh-my-zsh" ]]; then
                # Check parent directory thus oh-my-zsh root dir
                [[ -d ${zspec[dir]:h} ]] || continue
            else
                # Use -e flag bacause zspec[dir] returns directory and file
                [[ -e $zspec[dir] ]] || continue
            fi
            if [[ -n $zspec[if] ]]; then
                if ! eval "$zspec[if]" >/dev/null 2>&1; then
                    $is_verbose && __die "$zspec[name]: (not loaded)\n"
                    continue
                fi
            fi
            if [[ -n $zspec[on] ]]; then
                if [[ $zspec[from] != "local" && ! -e $ZPLUG_HOME/repos/${~zspec[on]} ]] ||
                    [[ $zspec[from] == "local" && ! -e ${~zspec[on]} ]]; then
                    $is_verbose && __die "$zspec[name]: (not loaded)\n"
                    continue
                fi
            fi
        }

        dirname="${zspec[name]%*/}"
        basename="${zspec[name]#*/}"

        case $zspec[as] in
            "command")
                [[ -d $ZPLUG_HOME/bin ]] || mkdir -p $ZPLUG_HOME/bin
                # Add parent directories to fpath if any files starting in _* exist
                load_fpaths+=(${zspec[dir]}{_*,/**/_*}(N-.:h))
                dst=${${zspec[file]:+$ZPLUG_HOME/bin/$zspec[file]}:-$ZPLUG_HOME/bin}

                zspec[dir]=${zspec[dir]%/}
                if [[ -f $zspec[dir]${zspec[of]:+"/$zspec[of]"} ]]; then
                    load_commands+=($zspec[dir]${zspec[of]:+"/$zspec[of]"} $dst)
                elif [[ -f $zspec[dir]${zspec[of]:+"/$zspec[of]"}/$basename ]]; then
                    load_commands+=($zspec[dir]${zspec[of]:+"/$zspec[of]"}/$basename $dst)
                elif [[ -f $zspec[dir]/$basename ]]; then
                    load_commands+=($zspec[dir]/$basename $dst)
                elif [[ -f $zspec[dir] ]]; then
                    load_commands+=($zspec[dir] $dst)
                else
                    # For brace
                    src_a=( $(zsh -c "echo ${zspec[dir]}/${zspec[of]:-"*(*N.)"}" 2>/dev/null) )
                    for src in $src_a
                    do
                        load_commands+=($src $dst)
                    done
                fi
                ;;

            "plugin")
                if [[ $zspec[from] == "oh-my-zsh" ]]; then
                    load_omz() {
                        if ! $loaded_omz; then
                            loaded_omz=true
                            export ZSH=$ZPLUG_HOME/repos/$_zplug_omz_repo
                            # Insert to the top
                            load_plugins=($ZSH/oh-my-zsh.sh ${load_plugins[@]})
                        fi
                    }

                    # oh-my-zsh
                    case $zspec[name] in
                        plugins/*)
                            load_fpaths+=(${zspec[dir]}/{_*,**/_*}(N-.:h))
                            temporary_array=( $zspec[dir]/${~zspec[of]:-"*.plugin.zsh(-.N)"} )
                            if (( $zspec[nice] > 9 )); then
                                nice_plugins+=( ${temporary_array[@]} )
                            else
                                load_plugins+=( ${temporary_array[@]} )
                            fi
                            (( $#temporary_array > 0 )) && load_omz
                            ;;
                        themes/*)
                            load_fpaths+=(${zspec[dir]}/{_*,**/_*}(N-.:h))
                            themes_ext=(.zsh-theme .theme-zsh)
                            temporary_array=( ${zspec[dir]}${zspec[of]:-${^themes_ext}(-.N)} )
                            if (( $zspec[nice] > 9 )); then
                                nice_plugins+=( ${temporary_array[@]} )
                            else
                                load_plugins+=( ${temporary_array[@]} )
                            fi
                            (( $#temporary_array > 0 )) && load_omz
                            ;;
                        lib/*)
                            load_fpaths+=(${zspec[dir]}/{_*,**/_*}(N-.:h))
                            temporary_array=( $zspec[dir]${~zspec[of]:-".zsh(-.N)"} )
                            if (( $zspec[nice] > 9 )); then
                                nice_plugins+=( ${temporary_array[@]} )
                            else
                                load_plugins+=( ${temporary_array[@]} )
                            fi
                            (( $#temporary_array > 0 )) && load_omz
                            ;;
                    esac

                else
                    # NOT oh-my-zsh
                    plugins_ext=(plugin.zsh zsh zsh-theme)
                    for ext in ${plugins_ext[@]}
                    do
                        if [[ -n $zspec[of] ]]; then
                            glob_patterns=( $zspec[dir]/${~zspec[of]}(-.N) )
                            if (( $#glob_patterns == 0 )); then
                                glob_patterns+=( $zspec[dir]/${~zspec[of]}.$ext(-.N) )
                                glob_patterns+=( $(zsh -c "echo ${zspec[dir]}/${zspec[of]:-"*(*N.)"}" 2>/dev/null) )
                            fi
                        else
                            glob_patterns=( $zspec[dir]/*.$ext(-.N) )
                            # Support user/repo.ext
                            glob_patterns+=( $zspec[dir].$ext(-.N) )
                        fi
                        if (( $#glob_patterns > 0 )); then
                            break
                        fi
                    done

                    # Add files to fpath
                    load_fpaths+=(${zspec[dir]}/_*(N-.:h))
                    if [[ -n $zspec[of] ]]; then
                        load_fpaths+=(${zspec[dir]}/$zspec[of]/_*(N-.:h))
                    fi

                    if (( $zspec[nice] > 9 )); then
                        nice_plugins+=(${glob_patterns[@]})
                    else
                        load_plugins+=(${glob_patterns[@]})
                    fi
                fi
                ;;

            "none")
                return 0
                ;;

            *)
                __die "$zspec[as]: as tag must be command or plugin\n"
                return 1
                ;;
        esac

        if [[ -n $zspec[ignore] ]]; then
            if [[ $zspec[from] == "oh-my-zsh" ]]; then
                load_ignores=( $ZPLUG_HOME/repos/$_zplug_omz_repo/${~zspec[ignore]}(N) )
            else
                load_ignores=( $zspec[dir]/${~zspec[ignore]}(N) )
            fi

            for ignore in ${load_ignores[@]}
            do
                # Commands
                if [[ -n $load_commands[(i)$ignore] ]]; then
                    unset "load_commands[$ignore]"
                fi
                # Plugins
                load_plugins=(${load_plugins#$ignore})
                nice_plugins=(${nice_plugins#$ignore})
                # fpath
                load_fpaths=(${load_fpaths#$ignore})
            done
        fi
    done

    # Commands
    for f in ${(k)load_commands}
    do
        [[ -f $f ]] && ln -snf "$f" "$load_commands[$f]"
    done
    path=("$ZPLUG_HOME/bin" $path)
    typeset -gx -U path

    # Plugins
    for f in ${load_plugins[@]}
    do
        # Use -e flag to check existing
        if [[ -f $f ]]; then
            source "$f"
            if [[ $status -eq 0 ]] && $is_verbose; then
                __put "\033[32m  Loaded\033[m ${f/$ZPLUG_HOME\/repos\//}\n"
            fi
        fi
    done
    # NOTE: set fpath before compinit
    fpath=(${(u)load_fpaths} $fpath)
    compinit -i -d "$ZPLUG_HOME/zcompdump"

    for f in ${nice_plugins[@]}
    do
        # Use -e flag to check existing
        if [[ -f $f ]]; then
            source "$f"
            if [[ $status -eq 0 ]] && $is_verbose; then
                __put "\033[32m  Loaded\033[m ${f/$ZPLUG_HOME\/repos\//} \033[33mafter running compinit\033[m\n"
            fi
        fi
    done

    [[ -f $ZPLUG_CACHE_FILE ]] && chmod a+w $ZPLUG_CACHE_FILE
    {
        __put '#!/bin/zsh\n\n'
        __put '# This file was generated by zplug\n'
        __put '# *** DO NOT EDIT THIS FILE ***\n\n'
        __put '[[ $- =~ i ]] || exit\n'
        __put 'export PATH="%s:$PATH"\n' "$ZPLUG_HOME/bin"
        __put 'export ZSH=%s\n\n' "$ZPLUG_HOME/repos/$_zplug_omz_repo"
        __put '_zplug_repos=(${(kv)zplugs})\n'
        __put '_zplug_saved=(%s)\n' "${(qqqkv)zplugs}"
        __put 'if [[ $_zplug_repos != $_zplug_saved ]]; then\n'
        if $is_verbose; then
            __put '  ZPLUG_USE_CACHE=false zplug load --verbose\n  return $status\n'
        else
            __put '  ZPLUG_USE_CACHE=false zplug load\n  return $status\n'
        fi
        __put 'fi\n'
        __put 'if $is_verbose; then\n'
        __put '  echo "Static loading..." >&2\n'
        __put 'fi\n'
        if (( $#load_plugins > 0 )); then
            __put 'source %s\n' "${(qqq)load_plugins[@]}"
        fi
        __put '\n# fpath\n'
        __put 'fpath=(%s $fpath)\n' "${(u)load_fpaths}"
        __put 'compinit -i -d %s\n' "$ZPLUG_HOME/zcompdump"
        if (( $#nice_plugins > 0 )); then
            __put '\n# Loading after compinit\n'
            __put 'source %s\n' "${(qqq)nice_plugins[@]}"
        fi
    } >|$ZPLUG_CACHE_FILE
    [[ -f $ZPLUG_CACHE_FILE ]] && chmod a-w $ZPLUG_CACHE_FILE
}

__zplug::validator()
{
    if [[ $ZPLUG_THREADS != <-> ]]; then
        __die "\$ZPLUG_THREADS: must be an interger\n"
        return 1
    fi
    if [[ ! $ZPLUG_PROTOCOL =~ ^(HTTPS|https|SSH|ssh)$ ]]; then
        __die "\$ZPLUG_PROTOCOL: must be a secure protocol by HTTPS or SSH\n"
        return 1
    fi
    if [[ ! $ZPLUG_SHALLOW =~ ^(true|false)$ ]]; then
        __die "\$ZPLUG_SHALLOW: must be a boolean (true/false)\n"
        return 1
    fi

    local line k fail=0
    local -A zspec

    # Do not run in parallel this for loop
    # bacause it is cannot increment fail variable
    for line in ${(k)zplugs}
    do
        zspec=( ${(@f)"$(__zplug::parser "$line")"} )
        for k in ${(k)zspec}
        do
            if [[ $zspec[$k] == "-EMP-" ]]; then
                zspec[$k]=""
            fi
        done

        # as: must (default: plugin)
        if [[ ! $zspec[as] =~ ^(command|plugin|none)$ ]]; then
            __die "\033[31m[$ZPLUG_NAME] #syntax error# tag 'as:' takes ['command','plugin'] (zplug \"$zspec[name]\")\033[m\n"

            # Remove that key and value
            unset "zplugs[$zspec[name]]"
            # Increments if it fails
            let fail++
        fi

        # from: opt
        if [[ -n $zspec[from] ]]; then
            if [[ ! $zspec[from] =~ ^(gh-r|gist|oh-my-zsh|bitbucket|github|local)$ ]]; then
                __die "\033[31m[$ZPLUG_NAME] #syntax error# tag 'from:' takes ['gh-r','gist','oh-my-zsh','bitbucket','github','local'] (zplug \"$zspec[name]\")\033[m\n"
                unset "zplugs[$zspec[name]]"; let fail++
            fi
            if [[ $zspec[from] == "oh-my-zsh" && ! $zspec[name] =~ ^(plugins|themes|lib) ]]; then
                __die "\033[31m[$ZPLUG_NAME] #syntax error# 'plugin name' must be starting with ['plugins','themes','lib'] (zplug \"$zspec[name]\")\033[m\n"
                unset "zplugs[$zspec[name]]"; let fail++
            fi
        fi

        # frozen: must (default: 0)
        if [[ ! $zspec[frozen] =~ ^(0|1)$ ]]; then
            __die "\033[31m[$ZPLUG_NAME] #syntax error# tag 'frozen:' takes [0,1] (zplug \"$zspec[name]\")\033[m\n"

            # Remove that key and value
            unset "zplugs[$zspec[name]]"
            # Increments if it fails
            let fail++
        fi

        # commit: opt
        if [[ -n $zspec[commit] ]] && (( $#zspec[commit] < 8 )); then
            __die "\033[31m[$ZPLUG_NAME] #syntax error# the length of tag 'commit:' must be eight characters or more (zplug \"$zspec[name]\")\033[m\n"

            # Remove that key and value
            unset "zplugs[$zspec[name]]"
            # Increments if it fails
            let fail++
        fi

        # nice: must
        if (( $zspec[nice] > 19 || $zspec[nice] < -20 )); then
            __die "\033[31m[$ZPLUG_NAME] #syntax error# tag 'nice:' must be an interger between -20..19 (zplug \"$zspec[name]\")\033[m\n"

            # Remove that key and value
            unset "zplugs[$zspec[name]]"
            # Increments if it fails
            let fail++
        fi
    done

    return $fail
}

__zplug::check()
{
    local line is_verbose=false
    local -A zspec
    local -a fail args

    fail=()

    while (( $# > 0 ))
    do
        case "$1" in
            --verbose)
                is_verbose=true
                ;;
            -*|--*)
                __die "$1: Unknown option\n"
                return 1
                ;;
            *)
                args+=("$1")
                ;;
        esac
        shift
    done

    for line in ${(u)${args[@]:gs:@::}}
    do
        zspec=( ${(@f)"$(__zplug::parser "$line")"} )
        [[ $zspec[from] == "local" ]] && continue

        if [[ $zspec[if] != "-EMP-" ]] && ! eval "$zspec[if]" >/dev/null 2>&1; then
            continue
        fi

        if [[ $zspec[from] != "oh-my-zsh" && ! -e $zspec[dir] ]] || [[ $zspec[from] == "oh-my-zsh" && ! -d ${zspec[dir]:h} ]]; then
            fail+=("$zspec[name]")
        fi
    done

    if (( $#fail > 0 )); then
        if $is_verbose; then
            __put "- \033[31m%s\033[m: not installed\n" "${(@nO)fail}"
        fi
        return 1
    else
        return 0
    fi
}

# WIP
__zplug::status()
{
    get_head_branch() {
        local head_branch
        if __git_version 1.7.10; then
            head_branch="$(git symbolic-ref -q --short HEAD)"
        else
            head_branch="${$(git symbolic-ref -q HEAD)#refs/heads/}"
        fi

        if [[ -z $head_branch ]]; then
            git rev-parse --short HEAD
            return 1
        fi
        __put "$head_branch\n"
    }

    get_remote_name() {
        local branch remote_name
        branch="$1"
        remote_name="$(git config branch.${branch}.remote)"

        if [[ -z $remote_name ]]; then
            __die "no remote repository\n"
            return 1
        fi
        __put "$remote_name\n"
    }

    get_remote_status() {
        local zspec_dir="$1"
        local dir="${zspec_dir##*/}"

        local state branch url
        local remote_name
        local merge_branch

        if [[ ! -e .git ]]; then
            state="not init"
        else
            branch="$(get_head_branch)"
            if [[ $status -eq 0 ]]; then
                remote_name="$(get_remote_name "$branch")"

                if [[ $status -eq 0 ]]; then
                    local remote_show
                    merge_branch="${$(git config branch.${branch}.merge)#refs/heads/}"
                    remote_show="$(git remote show "$remote_name")"
                    state="$(grep "^ *$branch *pushes" <<<"$remote_show" | sed 's/.*(\(.*\)).*/\1/')"

                    if [[ -z $state ]]; then
                        local -a behind_ahead
                        local -i behind ahead
                        local origin_head
                        behind_ahead=( $(git rev-list --left-right --count "$remote_name/$merge_branch"...$branch) )
                        behind=$behind_ahead[1] ahead=$behind_ahead[2]

                        if (( $behind > 0 )); then
                            state="local out of date"
                        else
                            origin_head="${$(git ls-remote origin HEAD)[1]}"
                            if ! git rev-parse -q "$origin_head" >/dev/null 2>&1; then
                                state="local out of date"
                            elif (( $ahead > 0 )); then
                                state="fast-forwardable"
                            else
                                state="up to date"
                            fi
                        fi
                    fi
                    url="$(grep '^ *Push' <<<"$remote_show" | sed 's/^.*URL: \(.*\)$/\1/')"
                else
                    state="$remote_name"
                    remote_name=
                fi
            else
                state="not on any branch"
            fi
        fi

        state="${state:-'?'}"
        if [[ "$state" == "up to date" ]]; then
            state="$(__ink --color green ${state})"
        else
            state="$(__ink --color red ${state})"
        fi
        dir="$(__ink --color blue ${zspec_dir})"

        # __put "($state) [${dir:-?}] (${branch:-?} -> ${remote_name:-?}/${merge_branch:-?}) URL: ${url:-?}\n"
        __put "($state) [${dir:-?}] URL: ${url:-?}\n"
    }

    local line cnt=0 is_select=false

    __job_control off

    case "$1" in
        --select)
            is_select=true
            shift
            ;;
        -*|--*)
            __die "$1: Unknown option\n"
            return 1
            ;;
    esac

    filter="$(__get_filter "$ZPLUG_FILTER")"
    if $is_select; then
        args=(${(@f)"$(echo "${(Fk)zplugs}" | eval "$filter")"})
    else
        args=(${(u)${@:gs:@::}})
    fi

    for line in "${args[@]}"; do
        # Run installation in subprocess
        {
            trap 'kill -9 ${${(v)jobstates##*:*:}%"="*} $bg_pid &>/dev/null; __job_control on; trap - INT' INT

            # All variables are treated as local variable
            # because of background job (subprocess)
            local k bg_pid ret=1
            local -A zspec
            zspec=( ${(@f)"$(__zplug::parser "$line")"} )
            for k in ${(k)zspec}
            do
                if [[ ! -e $zspec[dir] ]]; then
                    continue
                fi
                if [[ $zspec[$k] == "-EMP-" ]]; then
                    zspec[$k]=""
                fi
            done

            __put "Checking status...  $line\n"

            __bg_rotation_bar & bg_pid=$!

            () {
                if [[ $zspec[from] == "oh-my-zsh" ]]; then
                    builtin cd $ZPLUG_HOME/repos/$_zplug_omz_repo &>/dev/null || return 2
                    get_remote_status $_zplug_omz_repo
                else
                    builtin cd $zspec[dir] &>/dev/null || return 2
                    get_remote_status $zspec[name]
                fi
            }
            # Return code of above unnamed function
            # Incidentally,
            # nothing is output even if it success or fails
            ret=$status

            kill -9 $bg_pid &>/dev/null

            case $ret in
                2)
                    sleep 1
                    __put "(not managed) [\033[34m$zspec[name]\033[m] URL: https://github.com/${zspec[name]}.git\n"
                    ;;
            esac
        } &

        # Prevent having too many subprocesses
        (( (cnt += 1) % ZPLUG_THREADS == 0 )) && wait
    done

    # Wait until all jobs known to the invoking shell have terminated
    wait

    __job_control on

    unfunction get_remote_name get_head_branch get_remote_status
}

__zplug::clone()
{
    local repository
    local tag_of tag_commit tag_from tag_at tag_do
    local url_format ret

    while (( $# > 0 )); do
        case "$1" in
            --of)
                tag_of="$2"; shift
                ;;
            --commit)
                tag_commit="$2"; shift
                ;;
            --from)
                tag_from="$2"; shift
                ;;
            --at)
                tag_at="$2"; shift
                ;;
            --do)
                tag_do="$2"; shift
                ;;
            -*|--*)
                return 1
                ;;
            *)
                repository="$1"
                ;;
        esac
        shift
    done

    case "$tag_from" in
        oh-my-zsh)
            repository="$_zplug_omz_repo"
            ;&

        github)
            if [[ $ZPLUG_PROTOCOL =~ ^(HTTPS|https)$ ]]; then
                # Create the format of URL used to git clone
                # When vim-plug clones a repository, it injects git::@ into the URL
                # It's a little hack to avoid username/password prompt
                # from git when the repository doesn't exist.
                # Such thing can happen when there's a typo in the argument,
                # or when the repository is removed from GitHub
                # For more information, see also vim-plug wiki.
                # HTTPS: "https://git::@github.com/%s.git"
                url_format="https://git::@github.com/${repository}.git"

                # However, Git 2.3.0 introduced $GIT_TERMINAL_PROMPT
                # which can be used to suppress user prompt
                if __git_version 2.3; then
                    # HTTPS (git 2.3+): "https://github.com/%s.git"
                    export GIT_TERMINAL_PROMPT=0
                    url_format="https://github.com/${repository}.git"
                fi
            elif [[ $ZPLUG_PROTOCOL =~ ^(SSH|ssh)$ ]]; then
                # SSH: "git@github.com:%s.git"
                url_format="git@github.com:${repository}.git"
            fi
            ;;

        bitbucket)
            if [[ $ZPLUG_PROTOCOL =~ ^(HTTPS|https)$ ]]; then
                # HTTPS: "https://git::@bitbucket.org/%s.git"
                url_format="https://git::@bitbucket.org/${repository}.git"
            elif [[ $ZPLUG_PROTOCOL =~ ^(SSH|ssh)$ ]]; then
                # SSH: "git@bitbucket.org:%s.git"
                url_format="git@bitbucket.org:${repository}.git"
            fi
            ;;

        gist)
            if [[ $ZPLUG_PROTOCOL =~ ^(HTTPS|https)$ ]]; then
                # the same as github
                #
                # HTTPS: "https://git::@github.com/%s.git"
                url_format="https://git::@gist.github.com/${repository}.git"

                if __git_version 2.3; then
                    # HTTPS (git 2.3+): "https://gist.github.com/%s.git"
                    export GIT_TERMINAL_PROMPT=0
                    url_format="https://gist.github.com/${repository}.git"
                fi
            elif [[ $ZPLUG_PROTOCOL =~ ^(SSH|ssh)$ ]]; then
                # SSH: "git@github.com:%s.git"
                url_format="git@gist.github.com:${repository}.git"
            fi
            ;;

        gh-r)
            local dirname
            dirname="${repository%/*}"
            [[ -d $dirname ]] || mkdir -p "$dirname"
            builtin cd "$dirname" &>/dev/null
            __zplug::releases "$repository" "$tag_of" "${tag_at:#master}"

            # Post-installation hooks
            builtin cd "$ZPLUG_HOME/repos/$repository" &>/dev/null
            if [[ -n $tag_do ]]; then
                if [[ $ret -eq 0 ]]; then
                    # Run command if git clone returns true
                    eval "$tag_do"
                fi
            fi

            return $status
            ;;

        *)
            __die "$tag_from: Unknown tag\n"
            return 1
            ;;
    esac

    if [[ ! $ZPLUG_PROTOCOL =~ ^(HTTPS|https|SSH|ssh)$ ]]; then
        __die "$ZPLUG_PROTOCOL: Invalid protocol for cloning\n"
        return 1
    fi

    if [[ -z $url_format ]]; then
        __die "$repository: Invalid user/repo format\n"
        return 1
    fi

    local shallow_clone
    if $ZPLUG_SHALLOW && (( $#tag_commit < 9 )); then
        shallow_clone="--depth=1"
    fi

    [[ $ret -eq 0 ]] &&
        git clone $shallow_clone \
        --recursive \
        --quiet \
        --branch $tag_at \
        "$url_format" "$repository" >/dev/null 2>&1
    ret=$status

    if (( $#tag_commit >= 8 )); then
        builtin cd "$line" && git checkout $tag_commit >/dev/null 2>&1
    fi

    # Post-installation hooks
    builtin cd "$ZPLUG_HOME/repos/$repository" &>/dev/null
    if [[ -n $tag_do ]]; then
        if [[ $ret -eq 0 ]]; then
            eval "$tag_do"
        fi
    fi

    return $ret
}

__zplug::clean()
{
    local is_force=false is_select=false

    case "$1" in
        --force)
            is_force=true
            shift
            ;;
        --select)
            is_select=true
            shift
            ;;
        -*|--*)
            __die "$1: Unknown option\n"
            return 1
            ;;
    esac

    clean_deadlinks() {
        local link
        for link in $ZPLUG_HOME/bin/*(@N)
        do
            if [[ -L $link ]] && [[ ! -e $link ]]; then
                command rm -f "$link"
            fi
        done
    }

    # Note:
    # How to remove elements from ordinary array or associative array
    # ordinary array   : array[num]=() or shift 1 array <= overwrite empty element or shift command
    # associative array: unset "array[key]"             <= unset array with double quotes
    local k v arg fail=0
    local -a repos args remove_args
    local -A zspec

    filter="$(__get_filter "$ZPLUG_FILTER")"
    if $is_select; then
        args=(${(@f)"$(echo "${(Fk)zplugs}" | eval "$filter")"})
        (( $#args == 0 )) && return 0
    else
        args=("$@")
    fi

    if (( $#args > 0 )); then
        for arg in "${args[@]}"
        do
            zspec=( ${(@f)"$(__zplug::parser "$arg")"} )

            if [[ -e $zspec[dir] ]]; then
                __put "- \033[31m%s\033[m\n" "$arg"
                if [[ $zspec[from] == "oh-my-zsh" ]]; then
                    remove_args+=("$ZPLUG_HOME/repos/$_zplug_omz_repo")
                else
                    remove_args+=("$ZPLUG_HOME/repos/$arg")
                fi
            else
                __die "%s: not managed by zplug\n" "$arg"
                let fail++
            fi
        done

        if (( fail > 0 )); then
            return 1
        fi

        __put "Remove really? [y/N]: "
        if $is_force || read -q; then
            command rm -rf "${(u)remove_args[@]}"
            command rmdir "${(u)remove_args[@]:h}" 2>/dev/null
            clean_deadlinks
            __put "\nRemoved\n"
        else
            __put "\nCanceled\n"
        fi

    else
        repos=("${(@f)$(find "$ZPLUG_HOME/repos" -maxdepth 2 -mindepth 2)}")

        # Remove the repository which is used from the candidates
        for v in "${(@v)zplugs}"
        do
            k="${${v##*dir:}%%, *}"
            if [[ $k =~ $_zplug_omz_repo ]]; then
                k=$ZPLUG_HOME/repos/$_zplug_omz_repo
            fi
            num="${repos[(i)$k]}"
            if [[ -n "$num" ]]; then
                repos[$num]=()
            fi
        done

        [[ -z ${repos[1]} ]] && return

        __put "\033[;1mThese repositories are no longer managed by zplug.\033[m\n"
        __put "- \033[31m%s\033[m\n" "${repos[@]}"
        __put "Remove? [y/N]: "
        if $is_force || read -q; then
            command rm -rf "${repos[@]}"
            command rmdir "${repos[@]:h}" 2>/dev/null
            clean_deadlinks
            __put "\nRemoved\n"
        else
            __put "\nCanceled\n"
        fi
    fi

    local repo
    for repo in ${(k)zplugs}
    do
        if [[ ! -e ${${zplugs[$repo]##*dir:}%%, *} ]]; then
            unset "zplugs[$repo]"
        fi
    done
}

__zplug::clear()
{
    local is_force=false

    case "$1" in
        --force)
            is_force=true
            shift
            ;;
        -*|--*)
            __die "$1: Unknown option\n"
            return 1
            ;;
    esac

    __put "Remove cache file? [y/N]: "

    if $is_force || read -q; then
        command rm -f $ZPLUG_CACHE_FILE
        __put "\nRemoved\n"
    else
        __put "\nCanceled\n"
    fi
}

__zplug::generate_external()
{
    if [[ -f $ZPLUG_EXTERNAL ]]; then
        return 0
    fi

    cat <<-TEMPLATE >$ZPLUG_EXTERNAL
	#!/bin/zsh
	# -*- mode: zsh -*-
	# vim:ft=zsh
	#
	# *** ZPLUG EXTERNAL FILE ***
	# You can register plugins or commands to zplug on the
	# command-line. If you use zplug on the command-line,
	# it is possible to write more easily its settings
	# by grace of the command-line completion.
	# In this case, zplug spit out its settings to
	# $ZPLUG_EXTERNAL instead of .zshrc.
	# If you launch new zsh process, zplug load command
	# automatically search this file and run source command.
	#
	#
	# Example:
	# zplug "b4b4r07/enhancd", as:plugin, of:"*.zsh"
	# zplug "rupa/z",          as:plugin, of:"*.sh"
	#
TEMPLATE
    # chmod a-w $ZPLUG_EXTERNAL
}

zplug() {
    local arg
    arg="$1"

    case "$arg" in
        help)
            shift
            echo "$ZPLUG_HELP"
            return 0
            ;;

        version)
            shift
            echo "$ZPLUG_NAME $ZPLUG_VERSION"
            return 0
            ;;

        status)
            shift
            __zplug::status "$@" ${(k)zplugs}
            return $status
            ;;

        check)
            shift
            __zplug::check "$@" ${(k)zplugs}
            return $status
            ;;

        update)
            shift
            __zplug::update ${@:-${(k)zplugs}}
            return $status
            ;;

        list)
            shift
            __zplug::list "$@"
            return $status
            ;;

        install)
            shift
            __zplug::install "$@" ${(k)zplugs}
            return $status
            ;;

        load)
            shift
            __zplug::load "$@"
            return $status
            ;;

        clean)
            shift
            __zplug::clean "$@"
            return $status
            ;;

        clear)
            shift
            __zplug::clear "$@"
            return $status
            ;;

        "")
            echo "$ZPLUG_HELP"
            return 1
            ;;

        */*)
            local -i max=0
            local -a args
            args=(${(s/, /)@:gs/,  */, })
            arg="${args[1]}"
            args[1]=()

            # if [[ $arg =~ ^[A-Za-z0-9._-]+/[A-Za-z0-9._-]+$ ]]; then
                # Check duplicate plugins
                # `s` option flags means `shinstdin`
                if [[ $- =~ s ]] && (( $+zplugs[$arg] )); then
                    __die "$arg: already managed\n"
                    return 1
                fi

                local cnt=0 stdin on on_name
                local -a task on_args specs
                task=("$arg")

                if [[ -p /dev/stdin ]]; then
                    stdin="$(cat <&0)"
                    on_args=(${(s/, /)stdin:gs/,  */, })
                    on_name="${on_args[1]}"
                    on_args[1]=()
                    task=("$on_name" "$arg")
                    let cnt++
                fi
                if [[ -p /dev/stdout ]]; then
                    echo "$@"
                    let cnt++
                fi
                if (( cnt >= 2 )); then
                    __die "$on_name: cannot install (2 or less pipelines)\n"
                    return 1
                fi

                local i tag
                local is_oh_my_zsh is_local
                for arg in "${task[@]}"
                do
                    is_oh_my_zsh=false
                    is_local=false
                    if [[ $arg == $on_name ]]; then
                        specs=("${on_args[@]}")
                    else
                        specs=("${args[@]}")
                    fi

                    for i in ${==specs[@]}
                    do
                        if [[ ${i%%:*} =~ ^($_zplug_tag_pattern)$ ]]; then
                            tag="${tag}${i%,}, "
                            if [[ $i == "from:oh-my-zsh" ]]; then
                                is_oh_my_zsh=true
                            elif [[ $i == "from:local" ]]; then
                                is_local=true
                            fi
                        else
                            __die "$i: invalid tag\n"
                            return 1
                        fi
                    done

                    tag="${tag%, }"
                    # Add to $zplugs(AA; key:"user/repo" => value:"tag:value")
                    if [[ -n ${zplugs[(I)${arg}]} ]]; then
                        local key
                        for key in ${(k)zplugs}
                        do
                            # Match existing key with optional @ characters at the end.
                            if [[ $key =~ ^$arg@*$ ]] && (( max < $#key )); then
                                 max=$#key
                                 arg="${key}@"
                            fi
                        done
                    fi
                    zplugs+=("$arg" "${tag:-}")
                    # Add dir tag to $zplugs
                    if $is_oh_my_zsh; then
                        zplugs[$arg]+="${zplugs[$arg]:+, }dir:$ZPLUG_HOME/repos/$_zplug_omz_repo/${arg:gs:@::}"
                    elif $is_local; then
                        if [[ $arg[1] =~ [~$/] ]]; then
                            zplugs[$arg]+="${zplugs[$arg]:+, }dir:"${~arg:gs:@::}""
                        else
                            zplugs[$arg]+="${zplugs[$arg]:+, }dir:$ZPLUG_HOME/${arg:gs:@::}"
                        fi
                    else
                        zplugs[$arg]+="${zplugs[$arg]:+, }dir:$ZPLUG_HOME/repos/${arg:gs:@::}"
                    fi
                    if [[ $arg != $on_name && -n $on_name ]]; then
                        zplugs[$arg]+="${zplugs[$arg]:+, }on:$on_name"
                    fi

                    if [[ $- =~ s ]]; then
                        __zplug::generate_external
                        chmod a+w $ZPLUG_EXTERNAL
                        echo "zplug ${arg}${tag:+, ${(q)tag}}" >>|$ZPLUG_EXTERNAL
                        # chmod a-w $ZPLUG_EXTERNAL
                    fi

                    tag=""
                done
            # else
            #     if [[ $arg =~ , ]]; then
            #         __die "$arg: must be put one or more spaces after comma\n"
            #     else
            #         __die "$arg: no such command\n"
            #     fi
            #     return 1
            # fi
            ;;
        *)
            __die "$arg: no such command\n"
            ;;
    esac

    __zplug::validator || return $status
}

_zplug()
{
    local curcontext="$curcontext" state line ret=1

    _arguments -C \
        '1: :->cmds' \
        '*:: :->args' && ret=0

    case $state in
        cmds)
            _values "zplug commands" \
                "install[Install described items (plugins/commands) in parallel]" \
                "load[Load installed items]" \
                "update[Update items in parallel]" \
                "check[Check whether an update or installation is available]" \
                "list[Show all of the zplugs in the current shell]" \
                "clean[Remove deprecated repositories]" \
                "clear[Remove cache file]" \
                "status[Check if remote branch is up-to-date]" \
                "version[Show version information]" \
                "help[Show help message and usage]"
            ret=0
            ;;
        args)
            case $line[1] in
                check)
                    _arguments \
                        '(--verbose)--verbose[show non-installed items in output]' \
                        '*:: :_files -W $ZPLUG_HOME/repos'
                    ret=0
                    ;;
                update)
                    _arguments \
                        '(- 1 *)--self[update zplug by itself]' \
                        '(--select)--select[select items with interactive filters]' \
                        '*:: :_files -W $ZPLUG_HOME/repos'
                    ret=0
                    ;;
                install)
                    _arguments \
                        '(--verbose)--verbose[show non-installed items in output]' \
                        '(--select)--select[select items with interactive filters]' \
                        '*:: :compadd -x "%F{green}Accept%f %Busername/reponame%b arguments"'
                    ret=0
                    ;;
                load)
                    _arguments \
                        '(--verbose)--verbose[display loading files]'
                    ret=0
                    ;;
                status|list)
                    _arguments \
                        '(--select)--select[select items with interactive filters]' \
                        '*:: :_files -W $ZPLUG_HOME/repos'
                    ret=0
                    ;;
                clean)
                    _arguments \
                        '(--force --select)--force[force the removing activity]' \
                        '(--select --force)--select[select items with interactive filters]' \
                        '*:: :_files -W $ZPLUG_HOME/repos'
                    ret=0
                    ;;
                clear)
                    _arguments \
                        '(--force)--force[force the removing activity]'
                    ret=0
                    ;;
                version|help)
                    compadd -x "%F{yellow}Completing%f %Bno arguments%b"
                    ret=0
                    ;;
                */*)
                    _values -S : -s , "zplug tags" \
                        "as[Specify whether to register as commands or to register as plugins]:as:(plugin command)" \
                        "of[Specify the pattern to source (for plugin) or relative path to export (for command)]:of:->of" \
                        "from[Specify the services you use to install]:from:(gh-r gist oh-my-zsh github bitbucket local)" \
                        "at[Support branch/tag installation]:at:" \
                        "file[Specify filename you want to rename]:file:" \
                        "dir[Installation directory (RO)]:dir:->dir" \
                        "if[Specify the conditions under which to source or add to \$PATH]:if:" \
                        "do[Run commands after installation/update]:do:" \
                        "frozen[Do not update unless explicitly specified]:frozen:(0 1)" \
                        "commit[Support commit installation]:commit:" \
                        "on[Dependencies (RO)]:on:->on" \
                        "nice[Priority of loading the plugins]:nice:->nice" && ret=0
                    case $state in
                        on|dir)
                            compadd -x "%F{green}READ ONLY%f %Bno arguments%b"
                            ;;
                        of)
                            compadd -J 'command/plugin' -x "%F{yellow}Completing%f %BExample patterns%b" \
                                '*.zsh' \
                                '*.sh' \
                                'zsh/*.zsh' \
                                '*.plugin.zsh' \
                                'init.zsh'
                            compadd -J 'gh-r' -x "%F{yellow}Completing%f %BGitHub Releases (example)%b" \
                                'amd64' \
                                'darwin*amd64' \
                                'linux*amd64' \
                                '386' \
                                'darwin*386' \
                                'linux*386' \
                                'darwin' \
                                'linux'
                            ;;
                        nice)
                            compadd -V 'default' -x "%F{yellow}Completing%f %Bpriority (default)%b" 0
                            compadd -V 'high' -x "%F{yellow}Completing%f %Bpriority (high)%b" -- {-1..-20}
                            compadd -V 'low' -x "%F{yellow}Completing%f %Bpriority (low)%b" {1..9}
                            compadd -V 'lowest' -x "%F{yellow}Completing%f %Bpriority (low) after compinit%b" {10..19}
                            ;;
                    esac
                    ;;
            esac
            ;;
    esac

    return ret
}

__zplug::reset()
{
    unset zplugs

    unfunction \
        __die \
        __put \
        __ink \
        __log \
        __get_filter \
        __version_requirement \
        __git_version \
        __zsh_version \
        __job_control \
        __bg_rotation_bar \
        __zplug::releases \
        __zplug::list \
        __zplug::self_update \
        __zplug::v2 \
        __zplug::update \
        __zplug::install \
        __zplug::parser \
        __zplug::load \
        __zplug::validator \
        __zplug::check \
        __zplug::status \
        __zplug::clone \
        __zplug::clean \
        __zplug::clear \
        __zplug::generate_external \
        zplug \
        _zplug
}

if ! __zsh_version 4.3.9; then
    __die "zplug does not work this version of zsh $ZSH_VERSION.\n"
    __die "You must use zsh 4.3.9 or later.\n"

    __zplug::reset && unfunction __zplug::reset
    return 1
fi

if (( ! $+commands[git] )); then
    __die "git: not found in \$PATH\n"
    __die "zplug depends on git 1.7 or later.\n"

    __zplug::reset && unfunction __zplug::reset
    return 1
fi

typeset -i is_ready_zplug
if (( is_ready_zplug++ == 0 )); then
    # For __ink
    autoload -Uz colors
    colors

    [[ -f $ZPLUG_EXTERNAL ]] && source $ZPLUG_EXTERNAL
    if (( ! $+functions[compdef] )); then
        autoload -Uz compinit
        compinit -C
    fi
    compdef _zplug zplug
fi


# __END__ {{{1
# vim:fdm=marker fdc=3 ft=zsh ts=4 sw=4 sts=4:
